# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-08 06:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../source/How-To-Guides/Using-callback-groups.rst:2
msgid "Using Callback Groups"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:4
msgid ""
"When running a node in a Multi-Threaded Executor, ROS 2 offers callback "
"groups as a tool for controlling the execution of different callbacks. "
"This page is meant as a guide on how to use callback groups efficiently. "
"It is assumed that the reader has a basic understanding about the concept"
" of :doc:`executors <../Concepts/Intermediate/About-Executors>`."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:11
msgid "Table of Contents"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:14
msgid "Basics of callback groups"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:16
msgid ""
"When running a node in a Multi-Threaded Executor, ROS 2 offers two "
"different types of callback groups for controlling execution of "
"callbacks:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:20
msgid "Mutually Exclusive Callback Group"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:21
msgid "Reentrant Callback Group"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:23
msgid ""
"These callback groups restrict the execution of their callbacks in "
"different ways. In short:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:27
msgid ""
"Mutually Exclusive Callback Group prevents its callbacks from being "
"executed in parallel - essentially making it as if the callbacks in the "
"group were executed by a SingleThreadedExecutor."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:30
msgid ""
"Reentrant Callback Group allows the executor to schedule and execute the "
"group's callbacks in any way it sees fit, without restrictions. This "
"means that, in addition to different callbacks being run parallel to each"
" other, different instances of the same callback may also be executed "
"concurrently."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:35
msgid ""
"Callbacks belonging to different callback groups (of any type) can always"
" be executed parallel to each other."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:38
msgid ""
"It is also important to keep in mind that different ROS 2 entities relay "
"their callback group to all callbacks they spawn. For example, if one "
"assigns a callback group to an action client, all callbacks created by "
"the client will be assigned to that callback group."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:43
msgid ""
"Callback groups can be created by a node's ``create_callback_group`` "
"function in rclcpp and by calling the constructor of the group in rclpy. "
"The callback group can then be passed as argument/option when creating a "
"subscription, timer, etc."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:49
#: ../../source/How-To-Guides/Using-callback-groups.rst:196
#: ../../source/How-To-Guides/Using-callback-groups.rst:282
#: ../../source/How-To-Guides/Using-callback-groups.rst:448
#: ../../source/How-To-Guides/Using-callback-groups.rst:502
#: ../../source/How-To-Guides/Using-callback-groups.rst:525
msgid "C++"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:61
#: ../../source/How-To-Guides/Using-callback-groups.rst:248
#: ../../source/How-To-Guides/Using-callback-groups.rst:347
#: ../../source/How-To-Guides/Using-callback-groups.rst:455
#: ../../source/How-To-Guides/Using-callback-groups.rst:509
#: ../../source/How-To-Guides/Using-callback-groups.rst:553
msgid "Python"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:69
msgid ""
"If the user does not specify any callback group when creating a "
"subscription, timer, etc., this entity will be assigned to the node's "
"default callback group. The default callback group is a Mutually "
"Exclusive Callback Group and it can be queried via "
"``NodeBaseInterface::get_default_callback_group()`` in rclcpp and via "
"``Node.default_callback_group`` in rclpy."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:76
msgid "About callbacks"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:78
msgid ""
"In the context of ROS 2 and executors, a callback means a function whose "
"scheduling and execution is handled by an executor. Examples of callbacks"
" in this context are"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:82
msgid "subscription callbacks (receiving and handling data from a topic),"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:83
msgid "timer callbacks,"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:84
msgid "service callbacks (for executing service requests in a server),"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:85
msgid "different callbacks in action servers and clients,"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:86
msgid "done-callbacks of Futures."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:88
msgid ""
"Below are a couple important points about callbacks that should be kept "
"in mind when working with callback groups."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:91
msgid ""
"Almost everything in ROS 2 is a callback! Every function that is run by "
"an executor is, by definition, a callback. The non-callback functions in "
"a ROS 2 system are found mainly at the edge of the system (user and "
"sensor inputs etc)."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:95
msgid ""
"Sometimes the callbacks are hidden and their presence may not be obvious "
"from the user/developer API. This is the case especially with any kind of"
" “synchronous” call to a service or an action (in rclpy). For example, "
"the synchronous call ``Client.call(request)`` to a service adds a "
"Future's done-callback that needs to be executed during the execution of "
"the function call, but this callback is not directly visible to the user."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:106
msgid "Controlling execution"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:108
msgid ""
"In order to control execution with callback groups, one can consider the "
"following guidelines."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:111
msgid "For the interaction of an individual callback with itself:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:113
msgid ""
"Register it to a Reentrant Callback Group if it should be executed in "
"parallel to itself. An example case could be an action/service server "
"that needs to be able to process several action calls in parallel to each"
" other."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:117
msgid ""
"Register it to a Mutually Exclusive Callback Group if it should **never**"
" be executed in parallel to itself. An example case could be a timer "
"callback that runs a control loop that publishes control commands."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:120
msgid "For the interaction of different callbacks with each other:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:122
msgid ""
"Register them to the same Mutually Exclusive Callback Group if they "
"should **never** be executed in parallel. An example case could be that "
"the callbacks are accessing shared critical and non-thread-safe "
"resources."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:125
msgid ""
"If they should be executed in parallel, you have two options, depending "
"on whether the individual callbacks should be able to overlap themselves "
"or not:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:128
msgid ""
"Register them to different Mutually Exclusive Callback Groups (no overlap"
" of the individual callbacks)"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:130
msgid ""
"Register them to a Reentrant Callback Group (overlap of the individual "
"callbacks)"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:132
msgid ""
"An example case of running different callbacks in parallel is a Node that"
" has a synchronous service client and a timer calling this service. See "
"the detailed example below."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:137
msgid "Avoiding deadlocks"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:139
msgid ""
"Setting up callback groups of a node incorrectly can lead to deadlocks "
"(or other unwanted behavior), especially if one desires to use "
"synchronous calls to services or actions. Indeed, even the API "
"documentation of ROS 2 mentions that synchronous calls to actions or "
"services should not be done in callbacks, because it can lead to "
"deadlocks. While using asynchronous calls is indeed safer in this regard,"
" synchronous calls can also be made to work. On the other hand, "
"synchronous calls also have their advantages, such as making the code "
"simpler and easier to understand. Hence, this section provides some "
"guidelines on how to set up a node's callback groups correctly in order "
"to avoid deadlocks."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:152
msgid ""
"First thing to note here is that every node's default callback group is a"
" Mutually Exclusive Callback Group. If the user does not specify any "
"other callback group when creating a timer, subscription, client etc., "
"any callbacks created then or later by these entities will use the node's"
" default callback group. Furthermore, if everything in a node uses the "
"same Mutually Exclusive Callback Group, that node essentially acts as if "
"it was handled by a Single-Threaded Executor, even if a multi-threaded "
"one is specified! Thus, whenever one decides to use a Multi-Threaded "
"Executor, some callback group(s) should always be specified in order for "
"the executor choice to make sense."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:164
msgid ""
"With the above in mind, here are a couple guidelines to help avoid "
"deadlocks:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:166
msgid ""
"If you make a synchronous call in any type of a callback, this callback "
"and the client making the call need to belong to"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:169
msgid "different callback groups (of any type), or"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:170
msgid "a Reentrant Callback Group."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:172
msgid ""
"If the above configuration is not possible due to other requirements - "
"such as thread-safety and/or blocking of other callbacks while waiting "
"for the result (or if you want to make absolutely sure that there is "
"never a possibility of a deadlock), use asynchronous calls."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:177
msgid ""
"Failing the first point will always cause a deadlock. An example of such "
"a case would be making a synchronous service call in a timer callback "
"(see the next section for an example)."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:183
msgid "Examples"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:185
msgid ""
"Let us look at some simple examples of different callback group setups. "
"The following demo code considers calling a service synchronously in a "
"timer callback."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:190
msgid "Demo code"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:192
msgid "We have two nodes - one providing a simple service:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:277
msgid ""
"and another containing a client to the service along with a timer for "
"making service calls:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:284
msgid ""
"*Note:* The API of service client in rclcpp does not offer a synchronous "
"call method similar to the one in rclpy, so we wait on the future object "
"to simulate the effect of a synchronous call."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:387
msgid ""
"The client node's constructor contains options for setting the callback "
"groups of the service client and the timer. With the default setting "
"above (both being ``nullptr`` / ``None``), both the timer and the client "
"will use the node's default Mutually Exclusive Callback Group."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:394
msgid "The problem"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:396
msgid ""
"Since we are making service calls with a 1 second timer, the expected "
"outcome is that the service gets called once a second, the client always "
"gets a response and prints ``Received response``. If we try running the "
"server and client nodes in terminals, we get the following outputs."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:404
#: ../../source/How-To-Guides/Using-callback-groups.rst:467
msgid "Client"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:412
#: ../../source/How-To-Guides/Using-callback-groups.rst:482
msgid "Server"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:420
msgid ""
"So, it turns out that instead of the service being called repeatedly, the"
" response of the first call is never received, after which the client "
"node seemingly gets stuck and does not make further calls. That is, the "
"execution stopped at a deadlock!"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:425
msgid ""
"The reason for this is that the timer callback and the client are using "
"the same Mutually Exclusive Callback Group (the node's default). When the"
" service call is made, the client then passes its callback group to the "
"Future object (hidden inside the call-method in the Python version) whose"
" done-callback needs to execute for the result of the service call to be "
"available. But because this done-callback and the timer callback are in "
"the same Mutually Exclusive group and the timer callback is still "
"executing (waiting for the result of the service call), the done-callback"
" never gets to execute. The stuck timer callback also blocks any other "
"executions of itself, so the timer does not fire for a second time."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:439
msgid "Solution"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:441
msgid ""
"We can fix this easily - for example - by assigning the timer and client "
"to different callback groups. Thus, let us change the first two lines of "
"the client node's constructor to be as follows (everything else shall "
"stay the same):"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:462
msgid ""
"Now we get the expected result, i.e. the timer fires repeatedly and each "
"service call gets the result as it should:"
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:493
msgid ""
"One might consider if just avoiding the node's default callback group is "
"enough. This is not the case: replacing the default group by a different "
"Mutually Exclusive group changes nothing. Thus, the following "
"configuration also leads to the previously discovered deadlock."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:516
msgid ""
"In fact, the exact condition with which everything works in this case is "
"that the timer and client must not belong to the same Mutually Exclusive "
"group. Hence, all of the following configurations (and some others as "
"well) produce the desired outcome where the timer fires repeatedly and "
"service calls are completed."
msgstr ""

#: ../../source/How-To-Guides/Using-callback-groups.rst:532
#: ../../source/How-To-Guides/Using-callback-groups.rst:539
#: ../../source/How-To-Guides/Using-callback-groups.rst:546
#: ../../source/How-To-Guides/Using-callback-groups.rst:560
#: ../../source/How-To-Guides/Using-callback-groups.rst:567
#: ../../source/How-To-Guides/Using-callback-groups.rst:574
msgid "or"
msgstr ""

