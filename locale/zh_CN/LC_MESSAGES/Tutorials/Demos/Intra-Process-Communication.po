# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-08 06:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:7
msgid "Setting up efficient intra-process communication"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:11
msgid "Table of Contents"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:14
msgid "Background"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:16
msgid ""
"ROS applications typically consist of a composition of individual "
"\"nodes\" which perform narrow tasks and are decoupled from other parts "
"of the system. This promotes fault isolation, faster development, "
"modularity, and code reuse, but it often comes at the cost of "
"performance. After ROS 1 was initially developed, the need for efficient "
"composition of nodes became obvious and Nodelets were developed. In ROS 2"
" we aim to improve on the design of Nodelets by addressing some "
"fundamental problems that required restructuring of nodes."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:21
msgid ""
"In this demo we'll be highlighting how nodes can be composed manually, by"
" defining the nodes separately but combining them in different process "
"layouts without changing the node's code or limiting its abilities."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:24
msgid "Installing the demos"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:26
msgid ""
"See the :doc:`installation instructions <../../Installation>` for details"
" on installing ROS 2."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:28
msgid ""
"If you've installed ROS 2 from packages, ensure that you have ``ros-"
"rolling-intra-process-demo`` installed. If you downloaded the archive or "
"built ROS 2 from source, it will already be part of the installation."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:32
msgid "Running and understanding the demos"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:34
msgid ""
"There are a few different demos: some are toy problems designed to "
"highlight features of the intra process communications functionality and "
"some are end to end examples which use OpenCV and demonstrate the ability"
" to recombine nodes into different configurations."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:37
msgid "The two node pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:39
msgid ""
"This demo is designed to show that the intra process publish/subscribe "
"connection can result in zero-copy transport of messages when publishing "
"and subscribing with ``std::unique_ptr``\\ s."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:41
msgid "First let's take a look at the source:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:43
msgid "https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:127
msgid ""
"As you can see by looking at the ``main`` function, we have a producer "
"and a consumer node, we add them to a single threaded executor, and then "
"call spin."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:129
msgid ""
"If you look at the \"producer\" node's implementation in the ``Producer``"
" struct, you can see that we have created a publisher which publishes on "
"the \"number\" topic and a timer which periodically creates a new "
"message, prints out its address in memory and its content's value and "
"then publishes it."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:131
msgid ""
"The \"consumer\" node is a bit simpler, you can see its implementation in"
" the ``Consumer`` struct, as it only subscribes to the \"number\" topic "
"and prints the address and value of the message it receives."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:133
msgid ""
"The expectation is that the producer will print out an address and value "
"and the consumer will print out a matching address and value. This "
"demonstrates that intra process communication is indeed working and "
"unnecessary copies are avoided, at least for simple graphs."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:136
msgid ""
"Let's run the demo by executing ``ros2 run intra_process_demo "
"two_node_pipeline`` executable (don't forget to source the setup file "
"first):"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:154
msgid ""
"One thing you'll notice is that the messages tick along at about one per "
"second. This is because we told the timer to fire at about once per "
"second."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:157
msgid ""
"Also you may have noticed that the first message (with value ``0``) does "
"not have a corresponding \"Received message ...\" line. This is because "
"publish/subscribe is \"best effort\" and we do not have any \"latching\" "
"like behavior enabled. This means that if the publisher publishes a "
"message before the subscription has been established, the subscription "
"will not receive that message. This race condition can result in the "
"first few messages being lost. In this case, since they only come once "
"per second, usually only the first message is lost."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:163
msgid ""
"Finally, you can see that \"Published message...\" and \"Received message"
" ...\" lines with the same value also have the same address. This shows "
"that the address of the message being received is the same as the one "
"that was published and that it is not a copy. This is because we're "
"publishing and subscribing with ``std::unique_ptr``\\ s which allow "
"ownership of a message to be moved around the system safely. You can also"
" publish and subscribe with ``const &`` and ``std::shared_ptr``, but "
"zero-copy will not occur in that case."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:169
msgid "The cyclic pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:171
msgid ""
"This demo is similar to the previous one, but instead of the producer "
"creating a new message for each iteration, this demo only ever uses one "
"message instance. This is achieved by creating a cycle in the graph and "
"\"kicking off\" communication by externally making one of the nodes "
"publish before spinning the executor:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:174
msgid "https://github.com/ros2/demos/blob/rolling/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:256
msgid ""
"Unlike the previous demo, this demo uses only one Node, instantiated "
"twice with different names and configurations. The graph ends up being "
"``pipe1`` -> ``pipe2`` -> ``pipe1`` ... in a loop."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:259
msgid ""
"The line ``pipe1->pub->publish(msg);`` kicks the process off, but from "
"then on the messages are passed back and forth between the nodes by each "
"one calling publish within its own subscription callback."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:261
msgid ""
"The expectation here is that the nodes pass the message back and forth, "
"once a second, incrementing the value of the message each time. Because "
"the message is being published and subscribed to as a ``unique_ptr`` the "
"same message created at the beginning is continuously used."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:264
msgid "To test those expectations, let's run it:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:294
msgid ""
"You should see ever increasing numbers on each iteration, starting with "
"42... because 42, and the whole time it reuses the same message, as "
"demonstrated by the pointer addresses which do not change, which avoids "
"unnecessary copies."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:297
msgid "The image pipeline demo"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:299
msgid "In this demo we'll use OpenCV to capture, annotate, and then view images."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:303
msgid ""
"If you are on macOS and these examples do not work or you receive an "
"error like ``ddsi_conn_write failed -1``, then you'll need to increase "
"your system wide UDP packet size:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:310
msgid "These changes will not persist after a reboot."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:313
msgid "Simple pipeline"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:315
msgid ""
"First we'll have a pipeline of three nodes, arranged as such: "
"``camera_node`` -> ``watermark_node`` -> ``image_view_node``"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:317
msgid ""
"The ``camera_node`` reads from camera device ``0`` on your computer, "
"writes some information on the image and publishes it. The "
"``watermark_node`` subscribes to the output of the ``camera_node`` and "
"adds more text before publishing it too. Finally, the ``image_view_node``"
" subscribes to the output of the ``watermark_node``, writes more text to "
"the image and then visualizes it with ``cv::imshow``."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:321
msgid ""
"In each node the address of the message which is being sent, or which has"
" been received, or both, is written to the image. The watermark and image"
" view nodes are designed to modify the image without copying it and so "
"the addresses imprinted on the image should all be the same as long as "
"the nodes are in the same process and the graph remains organized in a "
"pipeline as sketched above."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:326
msgid ""
"On some systems (we've seen it happen on Linux), the address printed to "
"the screen might not change. This is because the same unique pointer is "
"being reused. In this situation, the pipeline is still running."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:329
msgid "Let's run the demo by executing the following executable:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:335
msgid "You should see something like this:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:341
msgid ""
"You can pause the rendering of the image by pressing the spacebar and you"
" can resume by pressing the spacebar again. You can also press ``q`` or "
"``ESC`` to exit."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:344
msgid ""
"If you pause the image viewer, you should be able to compare the "
"addresses written on the image and see that they are the same."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:347
msgid "Pipeline with two image viewers"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:349
msgid ""
"Now let's look at an example just like the one above, except it has two "
"image view nodes. All the nodes are still in the same process, but now "
"two image view windows should show up. (Note for macOS users: your image "
"view windows might be on top of each other). Let's run it with the "
"command:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:361
msgid ""
"Just like the last example, you can pause the rendering with the spacebar"
" and continue by pressing the spacebar a second time. You can stop the "
"updating to inspect the pointers written to the screen."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:363
msgid ""
"As you can see in the example image above, we have one image with all of "
"the pointers the same and then another image with the same pointers as "
"the first image for the first two entries, but the last pointer on the "
"second image is different. To understand why this is happening consider "
"the graph's topology:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:370
msgid ""
"The link between the ``camera_node`` and the ``watermark_node`` can use "
"the same pointer without copying because there is only one intra process "
"subscription to which the message should be delivered. But for the link "
"between the ``watermark_node`` and the two image view nodes the "
"relationship is one to many, so if the image view nodes were using "
"``unique_ptr`` callbacks then it would be impossible to deliver the "
"ownership of the same pointer to both. It can be, however, delivered to "
"one of them. Which one would get the original pointer is not defined, but"
" instead is simply the last to be delivered."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:372
msgid ""
"Note that the image view nodes are not subscribed with ``unique_ptr`` "
"callbacks. Instead they are subscribed with ``const shared_ptr``\\ s. "
"This means the system deliveres the same ``shared_ptr`` to both "
"callbacks. When the first intraprocess subscription is handled, the "
"internally stored ``unique_ptr`` is promoted to a ``shared_ptr``. Each of"
" the callbacks will receive shared ownership of the same message."
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:375
msgid "Pipeline with interprocess viewer"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:377
msgid ""
"One other important thing to get right is to avoid interruption of the "
"intra process zero-copy behavior when interprocess subscriptions are "
"made. To test this we can run the first image pipeline demo, "
"``image_pipeline_all_in_one``, and then run an instance of the stand "
"alone ``image_view_node`` (don't forget to prefix them with ``ros2 run "
"intra_process_demo`` in the terminal). This will look something like "
"this:"
msgstr ""

#: ../../source/Tutorials/Demos/Intra-Process-Communication.rst:383
msgid ""
"It's hard to pause both images at the same time so the images may not "
"line up, but the important thing to notice is that the "
"``image_pipeline_all_in_one`` image view shows the same address for each "
"step. This means that the intra process zero-copy is preserved even when "
"an external view is subscribed as well. You can also see that the "
"interprocess image view has different process IDs for the first two lines"
" of text and the process ID of the standalone image viewer in the third "
"line of text."
msgstr ""

